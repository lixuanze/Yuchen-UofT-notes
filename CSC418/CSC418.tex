\documentclass[11pt]{article}
% Libraries.

\usepackage{dsfont}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{esint}
\usepackage[margin=3cm]{geometry}
%\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{perpage}
\usepackage[dvipsnames, pdftex]{xcolor}
\usepackage{float}
\usepackage{xargs}
\usepackage{/Users/raina/Desktop/uoft-notes/raina}
\usepackage[
	colorinlistoftodos,
	prependcaption,
	textsize=tiny
]{todonotes}
\usepackage{minted}


% Property settings.
\MakePerPage{footnote}
\pagestyle{headings}

% Attr.
\title{CSC418\\ Lecture Notes}
\author{Yuchen Wang}
\date{\today}

\begin{document}
    \maketitle
    \tableofcontents
    \newpage

\section{Ray Tracing}
\subsection{Shading \label{Shading}}
\notation
The important variables in light reflection are \red{unit vectors}\\
\under{Light direction} $\vl$: a unit vector pointing toward the light source;\\
\under{View direction} $\vv$: a unit vector pointing toward the eye or camera;\\
\under{Surface normal} $\vn$: a unit vector perpendicular to the surface at the point where reflection is taking place.

\subsubsection{Lambertian Shading}
An observation by Lambert in the 18th century: the amount of energy from a light source that falls on an area of surface depends on the angle of the surface to the light.
\definition[Lambertian shading model]
The vector $\vl$ is computed by subtracting the intersection point of the ray and the surface from the light source position.\\
The pixel color
$$L = k_dI\max(0, \vn \cdot \vl)$$
where $k_d$ is the \ti{diffuse coefficient}, or the surface color; and $I$ is the intensity of the light source.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p1}
	\caption{Geometry for Lambertian shading}
\end{figure}
\remark
Because $\vn$ and $\vl$ are unit vectors, we can use $\vn \cdot \vl$ as a convenient shorthand for $\cos \theta$. This equation applies separately to the three color channels.
\remark
Lambertian shading is \ti{view independent:} the color of a surface does not depend on the direction from which you look. Therefore it does not produce any highlights and leads to a very matte, chalky appearance.

\subsubsection{Blinn-Phong Shading}
A very simple and widely used model for specular highlights by Phong (1975) and J.F.Blinn (1976).
\paragraph{Idea}
Produce reflection that is at its brightest when $\vv$ and $\vl$ are symmetrically positioned across the surface normal, which is when mirror reflection would occur; reflection then decreases smoothly as the vectors move away from a mirror configuration.\\
Compare the half vector $\vh$ with $\vn$: if $\vh$ is near the surface normal, the specular component should be bright and vice versa.
\definition[Blinn-Phong shading model]
\begin{align*}
	\vh &= \frac{\vv + \vl}{\norm{\vv + \vl}} \\
	L &= k_d I \max(0, \vn \cdot \vl) + k_s I \max(0, \vn \cdot \vh)^p
\end{align*}
where $k_s$ is the \ti{specular coefficient}, or the specular color of the surface, and $p > 1$.

\subsubsection{Ambient Shading}
A heuristic to avoid black shadows is to add a constant component to the shading model, one whose contribution to the pixel color depends only on the \blue{object hit}, with no dependence on the \blue{surface geometry} at all, as if surfaces were illuminated by ambient light that comes equally from everywhere.
\definition[simple shading model / Blinn-Phong model with ambient shading]
$$L = k_a I_a + k_d I \max (0, \vn \cdot \vl) + k_s I \max (0, \vn \cdot \vh)^p$$
where $k_a$ is the surface's ambient coefficient or ``ambient color", and $I_a$ is the ambient light intensity.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{p4}
\end{figure}


\subsubsection{Multiple Point Lights}
\property[superposition]
The effect by more than one light source is simply the sum of the effects of the light sources individually.
\definition[extended simple shading model]
$$L = k_a I_a + \sum_{i=1}^N[k_dI_i\max(0, \vn \cdot \vl_i) + k_sI_i \max(0, \vn \cdot \vh_i)^p]$$
where $I_i, \vl_i$ and $\vh_i$ are the intensity, direction, and half vector of the $i$-th light source.

\subsection{A Ray-Tracing Program}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{p2}
\end{figure}

\subsection{Shadows}
Recall from \ref{Shading} that light comes from direction $\vl$. If we imagine ourselves at a point $\vp$ on a surface being shaded, the point is in shadow if we ``look" in direction $\vl$ and see an object. If there are no objects, then the light is not blocked.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.73]{p3}
\end{figure}

\remark
The usual adjustment to avoid the problem of intersecting $\vp$ with the surface that generates it is to make the shadow ray check for $t \in [\epsilon, \infty)$ where $\epsilon$ is some small positive constant.

\remark
The code above assumes that $\vd$ and $\vl$ are not necessarily unit vectors. 

\subsection{Ideal Specular Reflection}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{p5}
	\caption{When looking into a perfect mirror, the viewer looking in direction $\vd$ will see whatever the viewer ``below" the surface would see in direction $\vr$}
\end{figure}
$$\vr = \vd - 2(\vd \cdot \vn)\vn$$
In the real world, a surface may reflect some colors more efficiently than others, so it shifts the colors of the objects it reflects (i.e. some energy is lost when the light reflects from the surface). \\
We implement the reflection by a recursive call of \ti{raycolor}:
\begin{framed}
\begin{minted}{C}
	color c = c + km * raycolor(p + sr, epsilon, max_t);
\end{minted}
\end{framed}
\noindent where $k_m$ is the specular RGB color, $p$ is the intersection of the viewing ray and the surface, $s \in [\epsilon, max\_t)$ for the same reason as we did with shadow rays: we don't want the reflection ray to hit the object that generates it.\\
To make sure that the recursive call will terminate, we need to add a maximum recursion depth.


\section{Data Structures for Graphics}
\subsection{Spatial Data Structures}
\subsubsection{Bounding Boxes}
\definition
	We first consider a 2D ray whose direction vector has positive $x$ and $y$ components. The 2D bounding box is defined by two horizontal and two vertical lines:
	$$x = x_{\min}$$
	$$x = x_{\max}$$
	$$y = y_{\min}$$
	$$y = y_{\max}$$
	The points bounded by these lines can be described in interval notation:
	$$(x,y) \in [x_{\min}, x_{\max}] \times [y_{\min}, y_{\max}]$$
	The intersection test can be phrased in terms of these intervals. First, we compute the ray parameter where the ray hits the line $x = x_{\min}$:
	$$t_{xmin} = \frac{x_{\min} - x_e}{x_d}$$
	We then make similar computations for $t_{xmax}, t_{ymin}$, and $t_{ymax}$. The ray hits the box if and only if the intervals $[t_{xmin}, t_{xmax}]$ and $[t_{ymin}, t_{ymax}]$ overlap.
	
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p6}
	\caption{The algorithm pseudocode.}
	\end{figure}
	
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{p7}
	\end{figure}
\paragraph{Issue 1}
The first thing we must address is the case when $x_d$ or $y_d$ is negative. If $x_d$ is negative, then the ray will hit $x_{\max}$ before it hits $x_{\min}$. Thus the code for computing $t_{xmin}$ and $t_{xmax}$ expands to:
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p8}
	\end{figure}
A similar code expansion must be made for the $y$ cases.
	
\paragraph{Issue 2}
A major concern is that horizontal and vertical rays have a zero value for $y_d$ and $x_d$, respectively. This will cause divide by zero which may be a problem. We define the \tb{rules for divide by zero}: \\
For any positive real number $a$,
$$+a / 0 = +\infty$$
$$-a / 0 = -\infty$$
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p9}
	\caption{The new code segment.}
	\end{figure}
	
\subsubsection{Hierarchical Bounding Boxes}
Basic idea: Place an axis-aligned 3D bounding box around all the objects. Since testing for intersection with the box is not free, rays that hit the bounding box will be more expensive to compute than in a brute force search, but rays that miss the box are cheaper. Such bounding boxes can be made hierarchical by partitioning the set of objects in a box and placing a box around each partition.
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p10}
	\end{figure}
\noindent The data structure for the hierarchy might be a tree with the large bounding box at the root and the two smaller bounding boxes as left and right subtrees. 
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p11}
	\end{figure}
\remark
Each object belongs to one of two sibling nodes, whereas a point a space may be inside both sibling nodes.

\subsubsection{Uniform Spatial Subdivision}
In spatial division, each point in space belongs to exactly one node, whereas objects may belong to many nodes.\\
The scene is partitioned into axis-aligned boxes. These boxes are all the same size, although they are not necessarily cubes. The ray traverses these boxes. When an object is hit, the traversal ends.

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p12}
	\end{figure}

\noindent This traversal is done in an increment fashion. We need to find the index $(i, j)$ of the first cell hit by the ray $\ve + t\vd$. Then we need to traverse the cells in an appropriate order. 

\subsection{Axis-Aligned Binary Space Partitioning}
We can also partition space in a hierarchical data structure such as a \ti{binary space partitioning tree} (BSP tree). It's common to use axis-aligned cutting planes for ray intersection.\\
A node in this structure contains a single cutting plane and a left and right subtree. Each subtree contains all the objects on one side of the cutting plane. Objects that pass through the plane are stored in both subtrees. \red{If we assume the cutting plane is parallel to the $yz$ plane at $x = D$, then the node class is:}
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{p13}
	\end{figure}
The intersection code can then be called recursively in an object-oriented style. The code considers the four cases:

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{p14}
	\end{figure}
The origin of these rays is a point at parameter $t_0$:
$$\vp = \va + t_0 \vb$$
The four cases are:
\begin{enumerate}
	\item The ray only interacts with the left subtree, and we need not test it for intersection with the cutting plane. It occurs for $x_p < D$ and $x_b < 0$.
	\item The ray is tested against the left subtree, and if there are no hits, it is then tested against the right subtree. We need to find the ray parameter at $x = D$, so we can make sure we only test for intersections within the subtree. This case occurs for $x_p < D$ and $x_b > 0$.
	\item This case is analogous to case 1 and occurs for $x_p > D$ and $x_b > 0$.
	\item This case is analogous to case 2 and occurs for $x_p > D$ and $x_b < 0$.
\end{enumerate}
The resulting traversal code handling these cases in order is:
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{p15}
	\end{figure}










\end{document}

